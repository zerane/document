# 前言 #

学java发现得学下设计模式，现在依稀只记得几个名词肯定是不行的，感觉内容比较多所以单列出来

# 正文 #
设计模式大体分为三类

> - 创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。
> - 结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。
> - 行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。
> ![](http://i.imgur.com/kKd5COY.jpg)

## 原则 ##
这玩意我竟然还记得一些，不过记得以前学的是前4个

1. 开闭原则：对扩展开放，对修改关闭；这个应该是为了程序的稳定性，保证原有代码不受更改影响
2. liskov替换原则：使用父类的地方可以使用子类替换，就是说子类应该是父类功能的延伸而非重写；保证继承层次的正确使用，避免无意义的继承
3. 依赖倒置原则：对抽象不对实现，对接口不对实现；减少调用者和被调用者之间的耦合
4. 接口隔离原则：将同一个接口中的无关的内容分割开来形成多个小接口，类似于数据库第三范式；减少同一类接口的耦合
5. 迪米特法则：减少不必要的调用目标；减少耦合，维持简洁
6. 合成复用原则：多用成员变量少用继承；避免不必要的继承，继承关系尽可能简洁

## 创建型模式 ##

@记得补充理解

### 1、工厂方法模式（Factory Method） ###

对于实现某个接口的多个类，由工厂类创建其实体，

主要问题：扩展性

- 普通工厂模式：通过字符串确定实体创建的目标，low
- 多个工厂方法模式：方法通过函数目标确定，一个函数对应个目标子类
- 静态工厂方法模式：同上，不过方法是静态的，因为只有创建，个人感觉并没有什么影响，而且不用实例化，一比上面两个都是渣渣- -

### 2、抽象工厂模式（Abstract Factory） ###

在工厂模式的基础上，将工厂抽象为一个接口

扩展的时候建立两个类，一个实现功能imp功能接口，一个创建产品实例imp工厂接口，感觉扩展性很不错的样子。

### 3、单例模式（singleton） ###

保证一个JVM已有一个实例存在（特殊需求），减少不必要的new

主要问题：多线程、特殊需求（单实例）

主要问题是实例最开始创建的时候需要互斥，主要思想就是执行创建的时候把实例所处的对象锁起来（synchronized）

其处于创建型模式的原因是因为主要问题在于实例的创建？

### 4、建造者模式（Builder） ###

可以看作多个工厂模式的集合，比如一个工厂模式的工厂类只生产一个实例，那么这里就是生产多个不同的实例组合- -不知道为啥要单列出来

### 5、原型模式(Prototye) ###

实现Cloneable接口，然后实例化一个原型，需要的时候克隆一个，在其基础上做自己的操作。

> cloneable接口是空接口，函数名可以自己起
> java中的clonable直接调用Object的clone会比较快捷，直接操作内存复制。

可以减少开销和代码量？是否还有别的作用

## 结构型模式 ##

### 6、适配器模式（Adapter） ###

主要思想是封装

主要问题：选择性实现函数，多类功能组合

应用场景：
- 对一个类实现一个接口：就创建一个子类继承它或者将它作为一个变量，并在子类上实现这个接口
- 用一个接口但不实现所有方法：创建一个抽象类实现接口中所有方法，继承这个类并实现部分方法；感觉这个说法有点不合适

### 7、装饰模式（Decorator） ###

对原有的东西进行修饰

主要问题：独立性

方法就是对已有的内容进行一层封装，比如可以创建一个类，包含要修饰的类，然后调用其函数并处理首尾

### 8、代理模式（Proxy） ###

主要问题:迪米特法则，维持简洁

类似工厂模式升级版，工厂模式是使用构造函数来“生产”实例，而代理则是直接处理事务。

### 9、外观模式 ###

主要问题：独立性

多个同一级别的内容可以通过协调者来协调以减少其耦合

### 10、桥接模式（Bridge） ###

主要问题：独立性，复用移植

接口实现也可以独立开来，数据库驱动和JDBC接口的例子挺不错

### 11、组合模式（Composite） ###

一定程度上忽略集合和元素的区别，将集合当做元素来看，从而通过更简洁的方式来表达一个复杂的结构

### 12、享元模式（Flyweight） ###

线程池、数据库连接池、内存池

主要问题：简洁，独立

通过对特定资源的统一管理，使得资源利用更加便捷，减少资源处理的难度，讲资源使用和管理独立开来。另：常与工厂模式一起使用，资源的创建与管理。

## 行为型模式 ##
![](http://i.imgur.com/Mhdx4GL.jpg)

### 13、策略模式（strategy） ###

一个功能多个算法，用以选择，比如排序提供快排、堆排序、插排让用户选，这个在之前有很多类似的，但是这里针对的是方法而不是对象或者实例，所以是行为型模式

### 14、模板方法模式（Template Method） ###

这个就是集合使用中使用list对象去操作linkedlist实例，使用通用的接口或者方法去使用特定的功能，这么一说感觉上面那个策略模式使用list的例子描述也挺好

### 15、观察者模式（Observer） ###

多个目标需要由同一个目标进行通知的时候，这多个目标都实现一个观察者接口到通知发出方注册

### 16、迭代子模式（Iterator） ###

迭代器...一目了然

写到这突然觉得java的容器类设计的好tm牛

### 17、责任链模式（Chain Of Responsibility） ###

链状的过程处理，可以内部修改而对整体的输入输出保持原样。

减少耦合，至少比网状的耦合程度要低一些？

理解有误，责任链处理的是同一个目标，多个处理器以链状方式排布，可以动态决定处理方式。比如一个处理器把锅甩给下一个处理器背。

### 18、命令模式（Command） ###

使用适配器（或者代理一样的东西？）将调用者和被调用者分开。

写到这突然觉得，这些设计模式有很大程度上是在描述，如何在各种情况（需求）下降低模块之间的耦合，然后因为都是要降低耦合所以都要代理、接口之类的东西来将各个模块黏合起来。

### 19、备忘录模式（Memento） ###

从表述来看就是建立一个备份以待复原，考虑两种情况

- 类似深复制，那么就相当于另外开辟了一个存储空间，将数据另外存了一份，纯粹的仓库
- 类似浅复制，那么就相当于要保留可能不用的内容，保留指针，使内容在存储中保留更长的时间，恢复速度快

### 20、状态模式（State） ###

根据某个属性值决定行为方式，这个属性称为状态...

### 21、访问者模式（Visitor） ###

主要应对对于目标内容和目标内容访问的分离，两者分别可以抽象为接口，这样两者的变化就可以分离开来，其实也是在这个场景下降低耦合程度

### 22、中介者模式（Mediator） ###

个人觉得应该叫协调者模式，对象变化会引起其他对象变化时可以引入一个中介者或者说协调者去处理这些变化，以减少类之间的复杂耦合，从网状结构变成星形结构

### 23、解释器模式（Interpreter） ###

用的比较少不仔细看了，貌似就是解析行为然后分别调用？然后着重强调了一下解析，搞不懂为啥要强调解析而不是模式

# 小结 #

对23种设计模式粗略的过了一遍，看到名字大概知道什么意思，和平常设计并没有矛盾之处，主要还是要保证代码简洁，可维护性，高类聚，低耦合，减少后续开发更改的代价，降低分模块开发所需要的交流。对于这些设计模式个人觉得了解即可，在实际使用中合理注意高类聚低耦合和可维护性即可，不必也没办法苛求使用设计模式，更重要的是在合适的时候使用模板和接口这些功能，因为这俩在结构设计中比较重要并且容易被遗忘


3/29/2017 9:55:21 PM 