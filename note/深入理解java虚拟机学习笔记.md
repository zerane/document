# 深入理解java虚拟机 #

## 前言 ##

之前的笔记太水了重新整理一下，并继续下面的部分

## 1.走近java ##
基本没有什么实质性内容，Java技术体系：

- java语言（java语言规范）
- 各种平台上的java虚拟机（java虚拟机规范）
- class文件格式
- java API 类库
- 第三方类库

## 2.内存区域和内存溢出异常 ##
本章包括内存区域、对象markword、各种内存异常

这里只记录内存区域部分
### 内存区域 ###

![](https://i.imgur.com/cLfqFi4.jpg)

- 程序计数器：类似pc
- 虚拟机栈：java的方法栈，一帧一个方法，具体内容见后
- 本地方法栈：native方法的栈，写到这时还不是很清楚。这两个方法栈太深都会stackoverflow
- java堆：常说的堆内存，对象存储区域，内存回收主要目标
- 方法区：加载的类信息
- 运行常量池：方法区一部分，包括class文件解析出来的常量，各种String之类的
- 直接内存：区分于堆内存，native堆的映射？

## 3.垃圾收集与内存分配策略 ##
包含很多内容，其中比较简单的直接列在这里，书中其他内容：日志分析，垃圾收集参数

- 可达分析算法，GC Roots
- 引用类别：强应用，软引用，弱引用，虚引用
- finalize()方法，每个对象最多只调用一次，且不保证一定会调用
- 方法区（永久代）回收，字符串常量池，类卸载
- Minor GC/Full GC

### 垃圾收集算法 ###

- 标记-清除：CMS，G1
- 复制算法：新生代常用
- 标记-整理：老年代常用
- 分代收集：意会

### 算法实现 ###

- 枚举根节点：stop the world，oopmap记录引用
- 安全点、安全区

### 实际收集器 ###
这里的并发并行与java中平常说的不太一样，
并行指收集器内部用了并行执行（但用户线程可能挂起），
并发指用户线程和收集器可以同时执行

- Serial：新生代复制算法，老年代（Serial Old）标记整理
- ParNew：，serial新生代的并行版本，新生代，并行，复制，server模式默认
- Parallel Scavenge：和ParNew性质基本一样，其他收集器着重降低停顿时间，这个着重吞吐量（垃圾收集时间占总运行时间的比重）
- Parallel Old：Parallel Scavenge老年代版本，吞吐量优先

上面四个基本就是（新生代复制，老年代标记整理）+并行的组合版本

- CMS（Concurrent Mark Sweep）：标记清除，四个阶段（初始标记，并发标记，重新标记，并发清除），停顿时间段，只需要在步骤1、3处停止世界
- G1：比较复杂，不详述

### 内存分配回收策略 ###
新生代（eden区 -> survivor区） -> 老年代

- 对象优先eden
- 大对象直接进入老年代
- 长期存活对象进入老年代
- 动态对象年龄判定（长期存活标准）
- 空间分配担保（minor gc）

## 4.java自带工具 ##
bin里，这里不详述

- java
- javac
- jps：类似ps，显示虚拟机进程
- jstat：收集运行数据
- jinfo：虚拟机配置信息
- jmap：生成内存dump
- jhat：分析内存dump用
- jstack：虚拟机线程
- HSDIS：jit代码反编译
- jconsole：可视化工具，功能很多
- visualVM：同上，功能也很多

## 5.调优案例 ##
内容很多，具体看书，记录一些可以调优或分析的方面

- 堆外内存，考虑直接内存溢出问题
- exec导致的缓慢，exec需要复制当前进程环境变量等
- 选择合适的垃圾收集器
- 选择合适的初始化内存大小
- 选择合适java版本
- 需要的时候跳过字节码验证
- ......

## 6.类文件结构 ##
这章内容极其繁琐，且很多没有什么记忆的价值，只记录部分信息

### 类文件内容 ###

- 魔数0xCAFEBABE
- 版本号，向下兼容
- 常量池
- 访问flag
- 自身、父类、接口
- 字段
- 方法
- 属性：code、exception、lineNumberTable（字节码与源码关系）、localVariableTable（局部变量表到java源码中定义）、SourceFile（class源码名称）、ConstantValue（静态变量初始值）、InnerClasses（内部类）、Deprecated（废弃，不推荐）&Synthetic（标识为编译器生成非源码生成）、StackMapTable（简要验证信息）、Signature（泛型使用）、BootstrapMethods（invodedynamic指令使用，此指令后有）

### 字节码指令 ###
略


## 7.虚拟机类加载机制 ##
类加载和加载不是一码事

### 类加载过程 ###
加载 -> 验证 -> 准备 -> 解析 -> 初始化 -> 使用 -> 卸载

其中（验证，准备，解析）称为连接，类似c/c++编译时期的连接

初始化时机：主动引用（使用其方法或者非final字段）

- 加载：从class文件或者其他地方获取class文件定义中的二进制数据
- 验证：包括文件格式验证（文件cafebabe、java版本、变量类型等）、元数据验证（父类、虚函数实现、final覆盖等）、字节码验证（运算类型、跳转范围等）、符号引用验证（存在类、访问权限）
- 准备：字段内存分类，并初始化为0（仅为0，初始化为源码中的变量是初始化阶段做的）
- 解析：符号引用替换为直接引用（字段、方法中的局部变量、函数调用等）包括（类接口解析、字段解析、类方法解析、接口方法解析）
- 初始化：静态变量赋初值，<clinit>方法，只会被一个线程初始化（多个类加载器呢？其他阶段呢？）

### 类加载器 ###

- 同一类加载器加载的类才可比（instanceof，class的equals）
- 双亲委派模型（启动类加载器、扩展类加载器、应用程序类加载器（我们用的默认加载器）），模型含义是加载器不以集成，而是以组合的方式使用父加载器代码。
- OSGi破坏双亲类加载器，模块热部署

## 8.虚拟机字节码执行引擎 ##

### 虚拟机栈 ###
即java方法栈

### 栈帧结构 ###
一个线程一个栈

- 局部变量表
- 操作数栈:类似pc
- 动态连接：相对于静态解析，个人理解：无法静态解析的方法，即实际可能调用多种方法
- 返回地址
- ......

### 方法调用 ###
解析和分派都是用于确定要调用目标代码（方法代码）的方法。

#### 解析 ####
调用的方法在编译时已经可以确定：

- 静态方法
- 私有方法
- 实例构造器
- 父类方法

即代码确定了实际调用方法，不会发生变化。

#### 分派 ####
编译期无法确定使用哪个方法实例。

宗量：方法接收者+参数（接收者在代码上看来是调用者的实际类型）

a.b(C d);

- 静态分派：根据参数(C)类型选择目标函数，静态即编译期确定
- 动态分派：根据调用者(a)选择目标函数，动态即运行时确定
- 单分派：根据单宗量选择方法
- 多分派：根据多宗量选择方法（java静态多，动态单）

#### 动态分派实现 ####
虚方法表：类中所有的方法，有重写则指向自己的方法，没有则指向实际使用（比如父类祖类）的方法。

### 动态语言支持 ###
主要是invokedynamic命令，主要为其他运行于java虚拟机上的解释执行语言服务，对我貌似目前没什么用，先不详述

- java.lang.invoke包
- MethodHandle类
- invokedynamic指令

可以通过MethodHandle调用祖类方法（不过反射也行吧？）

### 执行方法 ###

- 解释执行（python、js之类的）：代码简洁，但是编码时难以发现问题（比如敲错变量名...）
- 基于栈的指令集（java）：可移植，但是实现相同功能需要更多的指令
- 基于寄存器的指令集（机器码，c/c++）：指令简洁，但是不可移植（换平台需要重新编译）

## 9.案例 ##
案例描述直接看书，记录一些另外的知识

### 正统类加载（tomcat） ###
一个web服务器主要解决这么几个问题：

- 应用程序的类库分开，独立使用（比如不同web服务使用类的不同版本）
- 类库可以共享（比如spring），这里共享是指方法区，磁盘空间影响不大
- 服务器安全不受应用程序影响，此两者类库应独立
- JSP应用要支持HotSwap（替换JSP类）

一些tips

- tomcat中的类库：/common（都可见）,/server（仅tomcat自身可见）,/shared（所有应用程序可见）,/webapp/WEB_INF（单应用程序可见）
- common、server、shared被合并为/lib
- 使用不同的类加载器来实现类的可见性需求
- 单独的JSP类加载器以便卸载
- spring使用线程上下文加载器Thread.currentThread().getContextClassLoader()

### 灵活类加载（OSGi） ###

